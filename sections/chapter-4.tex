%
\section{Design \& Architecture}\label{sec:design_architecture}
%
This chapter will explain about the scanner architecture, things that have considered while designing the component and some of the useful techniques I have analyzed to make an efficient scanner to extract \acs{OSS} component.

\subsection{Scanner Architecture}
 The first task of developing this scanner is creating an automated \acs{OSS} component extractor because manual extraction of \acs{OSS} component is a tedious and redundant task, finding an automated system will reduce the time consumption and make it more cost effective. The manual \acs{OSS} extraction is suitable for small projects with less \acs{OSS} components consumption which is a very rare case. The \acs{OSS} scanner is built as a web application in this project by considering some useful advantages like accessibility across the devices, less maintenance and increased flexibility and scalability. Like traditional web-application the \acs{OSS} scanner has front-end and back-end applications. I have decided to break down the \acs{OSS} scanner into three major parts which are \acs{OSS} component Analyzer, Evaluator and Reporter. 
 \begin{figure}[h!]
 	\includegraphics[width=15cm]{includes/architetcure.png}
 	\centering
 	\caption{\acs{OSS} scanner architecture}
 	\label{fig:architecture}
 \end{figure}
\newpage
The figure ~\ref{fig:architecture} shows where the three major parts have been placed in the web -application. The \acs{OSS} component analyzer will be developed in the front-end because as per the research question the \acs{OSS} components should be scanned in the front-end(web browser). Once the \acs{OSS} components are extracted from the project, the meta information(name and version) will be sent to the \acs{OSS} component evaluator for finding the vulnerabilities. The OSS component evaluator and reporter are developed in the back-end. To make a clear understating, the figure ~\ref{fig:sequence} will show clear interaction between the components.
\begin{figure}[h!]
	\includegraphics[width=15cm]{includes/sequence_diagram.png}
	\centering
	\caption{\acs{OSS} scanner sequence diagram}
	\label{fig:sequence}
\end{figure} 
\subsection{Scanner Components}

As shown in figure ~\ref{fig:architecture} there are three main components involved in the design and architecture of the \acs{OSS} scanner. Following are the components which are inter related to each other and gives a big picture of their functionality. \acs{OSS} Component Analyzer, \acs{OSS} Component Evaluator and \acs{OSS} Reporter.

\textbf{\acs{OSS} Component Analyzer:} This component is mainly responsible for extracting the \acs{OSS} components used in the projects. This particular task should be performed on the client side where the scanning should take place in the browser. The inputs required in this interface by the user are Project name, description, members and project directory. After receiving the inputs, there are two stages of the automation process, first the scanner will detect what type of application framework is given as input so that the scanner can parse the targeted file for the further process. Once the target file is parsed, the second process will extract the \acs{OSS} component name and the version used in the project. It creates \acs{JSON} data with basic project information along with the list of \acs{OSS} components and its version. Overall the primary goal of this component is to extract all the \acs{OSS} components and It will send the data evaluation process.
	
\textbf{\acs{OSS} Component Evaluator:} This component evaluates the \acs{OSS} components which are extracted by the analyzer. The evaluation process component will be developed as a back-end application so that the process will be performed on the server side. This evaluation is performed with the help of \acs{NVD} database \acs{API} service. The extracted \acs{OSS} components will be searched in the \acs{NVD} database by using its name and version to find the known vulnerabilities registered under the respective component version. This component will be running asynchronously in the server because a project can have n-number of \acs{OSS} components. Once the \acs{OSS} components are evaluated, the information which is collected from the \acs{NVD} database is used for analysing the risk level of each \acs{OSS} component. Finally all the information is converted as a \acs{JSON} file and stored as container in Azure data storage.
	
\textbf{\acs{OSS} Reporter:} This component is a part of the scannerâ€™s user interface where the user can download the \acs{OSS} report of the project. This report shows all the basic information of the project and its \acs{OSS} component along with the vulnerability and the risk level of each component. This component simply generates a pdf report with all the above information retrieved from the database.
	
\subsection{Design Challenge}
Almost every software product development project has a unique set of problems. These issues can be a roadblock to development throughout system design and, more importantly, during implementation. There were several difficulties faced throughout the implementation of this thesis. The major problems that need to be addressed and a solution formed are listed below.

\textbf{Application framework:} Because I had never worked with Angular framework before, the first hurdle I had while starting implementation was familiarizing myself with it. I got acquainted to the Angular environment with the aid of several online tutorials and hands-on programming. The are few reasons why we chose to develop frontend application with  Angular framework because it has faster development process like having neat documentation for understanding Angular with a large developer community and it also helps us with efficient problem-solving patterns where the angular services helps to integrate the business logic with app user-interface.
	
\textbf{File structure:} The next challenge for me was trying to create a generic function that can extract the \acs{OSS} component name version from respected config files of the software project. This challenge was pretty time consuming because each software project can be built by using a different application framework and also each application framework has its own dependency manager. For instance, the Ruby on Rails application framework uses RubyGems as a dependency manager. The Ruby on Rails application framework generates file called Gemfile where all the required dependencies of the project will be mentioned there along with the version of the dependency. The file type of the the Gemfile is .gemfile.  Likewise each application framework have different file type as refereed in the table ~\ref{tab:configFiles}. To over come this challenge, when the project data is submitted at the beginning, the project data should pass a condition where it has to identify which application framework project it is. Once after identifying the application, the OSS component extraction will be performed based on the file type of config file. So for each application framework, there should be different extraction functions. 
	
	
\textbf{Finding the right regex:} Another challenge was finding the right regex for each config file. The harder part was extracting the \acs{OSS} component names and version from config files like Gemfile and requirements.txt. To overcome this challenge it was not that difficult because the same solution like file structure is required for the this challenge. When the user submits a Django or Ruby on Rails project, firstly as I said the condition will identify the application framework and based on the file type the extraction will be performed. The regex is implemented in the extraction function, for instance when you see the figure ~\ref{fig:ruby} which lists all the OSS components used in a Ruby on Rails project. Each line of the file will be sent for a cleaning process and delivers the component name and version which is extracted from each line. To extract the name and version from each line a proper regex is required. Like the Django and Ruby on Rails, the other application framework was no that difficult because most of the file types were xml and json files where the component name version can be easily extracted with the help of json and xml DOM parsing functions.  
	
\textbf{Verification:} Another issue was determining whether what I built corresponded to what was actually happening within the software. To do so, I ran my code on a set of test inputs to check if the program produced the same results. At the beginning, the results were not coming as expected, for instance the results will come without the component name or its version. This happens due to faulty regex commands, so it required lot of testing with many set of inputs to improve the extraction. There is another challenge where a same application framework can have different config files based on the type of the project. This challenge was with .Net projects because for each type of project it has different config file like stated in the table ~\ref{tab:configFiles}. So to overcome this challenge, only the .Net based projects has to pass multiple condition to identify in which type of project it belongs in .Net application framework.

%
